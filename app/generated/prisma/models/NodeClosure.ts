
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `NodeClosure` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model NodeClosure
 * 
 */
export type NodeClosureModel = runtime.Types.Result.DefaultSelection<Prisma.$NodeClosurePayload>

export type AggregateNodeClosure = {
  _count: NodeClosureCountAggregateOutputType | null
  _avg: NodeClosureAvgAggregateOutputType | null
  _sum: NodeClosureSumAggregateOutputType | null
  _min: NodeClosureMinAggregateOutputType | null
  _max: NodeClosureMaxAggregateOutputType | null
}

export type NodeClosureAvgAggregateOutputType = {
  depth: number | null
}

export type NodeClosureSumAggregateOutputType = {
  depth: number | null
}

export type NodeClosureMinAggregateOutputType = {
  ancestorId: string | null
  descendantId: string | null
  depth: number | null
}

export type NodeClosureMaxAggregateOutputType = {
  ancestorId: string | null
  descendantId: string | null
  depth: number | null
}

export type NodeClosureCountAggregateOutputType = {
  ancestorId: number
  descendantId: number
  depth: number
  _all: number
}


export type NodeClosureAvgAggregateInputType = {
  depth?: true
}

export type NodeClosureSumAggregateInputType = {
  depth?: true
}

export type NodeClosureMinAggregateInputType = {
  ancestorId?: true
  descendantId?: true
  depth?: true
}

export type NodeClosureMaxAggregateInputType = {
  ancestorId?: true
  descendantId?: true
  depth?: true
}

export type NodeClosureCountAggregateInputType = {
  ancestorId?: true
  descendantId?: true
  depth?: true
  _all?: true
}

export type NodeClosureAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which NodeClosure to aggregate.
   */
  where?: Prisma.NodeClosureWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of NodeClosures to fetch.
   */
  orderBy?: Prisma.NodeClosureOrderByWithRelationInput | Prisma.NodeClosureOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.NodeClosureWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` NodeClosures from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` NodeClosures.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned NodeClosures
  **/
  _count?: true | NodeClosureCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: NodeClosureAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: NodeClosureSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: NodeClosureMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: NodeClosureMaxAggregateInputType
}

export type GetNodeClosureAggregateType<T extends NodeClosureAggregateArgs> = {
      [P in keyof T & keyof AggregateNodeClosure]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateNodeClosure[P]>
    : Prisma.GetScalarType<T[P], AggregateNodeClosure[P]>
}




export type NodeClosureGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.NodeClosureWhereInput
  orderBy?: Prisma.NodeClosureOrderByWithAggregationInput | Prisma.NodeClosureOrderByWithAggregationInput[]
  by: Prisma.NodeClosureScalarFieldEnum[] | Prisma.NodeClosureScalarFieldEnum
  having?: Prisma.NodeClosureScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: NodeClosureCountAggregateInputType | true
  _avg?: NodeClosureAvgAggregateInputType
  _sum?: NodeClosureSumAggregateInputType
  _min?: NodeClosureMinAggregateInputType
  _max?: NodeClosureMaxAggregateInputType
}

export type NodeClosureGroupByOutputType = {
  ancestorId: string
  descendantId: string
  depth: number
  _count: NodeClosureCountAggregateOutputType | null
  _avg: NodeClosureAvgAggregateOutputType | null
  _sum: NodeClosureSumAggregateOutputType | null
  _min: NodeClosureMinAggregateOutputType | null
  _max: NodeClosureMaxAggregateOutputType | null
}

type GetNodeClosureGroupByPayload<T extends NodeClosureGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<NodeClosureGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof NodeClosureGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], NodeClosureGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], NodeClosureGroupByOutputType[P]>
      }
    >
  >



export type NodeClosureWhereInput = {
  AND?: Prisma.NodeClosureWhereInput | Prisma.NodeClosureWhereInput[]
  OR?: Prisma.NodeClosureWhereInput[]
  NOT?: Prisma.NodeClosureWhereInput | Prisma.NodeClosureWhereInput[]
  ancestorId?: Prisma.StringFilter<"NodeClosure"> | string
  descendantId?: Prisma.StringFilter<"NodeClosure"> | string
  depth?: Prisma.IntFilter<"NodeClosure"> | number
  ancestor?: Prisma.XOR<Prisma.NodeScalarRelationFilter, Prisma.NodeWhereInput>
  descendant?: Prisma.XOR<Prisma.NodeScalarRelationFilter, Prisma.NodeWhereInput>
}

export type NodeClosureOrderByWithRelationInput = {
  ancestorId?: Prisma.SortOrder
  descendantId?: Prisma.SortOrder
  depth?: Prisma.SortOrder
  ancestor?: Prisma.NodeOrderByWithRelationInput
  descendant?: Prisma.NodeOrderByWithRelationInput
}

export type NodeClosureWhereUniqueInput = Prisma.AtLeast<{
  ancestorId_descendantId?: Prisma.NodeClosureAncestorIdDescendantIdCompoundUniqueInput
  AND?: Prisma.NodeClosureWhereInput | Prisma.NodeClosureWhereInput[]
  OR?: Prisma.NodeClosureWhereInput[]
  NOT?: Prisma.NodeClosureWhereInput | Prisma.NodeClosureWhereInput[]
  ancestorId?: Prisma.StringFilter<"NodeClosure"> | string
  descendantId?: Prisma.StringFilter<"NodeClosure"> | string
  depth?: Prisma.IntFilter<"NodeClosure"> | number
  ancestor?: Prisma.XOR<Prisma.NodeScalarRelationFilter, Prisma.NodeWhereInput>
  descendant?: Prisma.XOR<Prisma.NodeScalarRelationFilter, Prisma.NodeWhereInput>
}, "ancestorId_descendantId">

export type NodeClosureOrderByWithAggregationInput = {
  ancestorId?: Prisma.SortOrder
  descendantId?: Prisma.SortOrder
  depth?: Prisma.SortOrder
  _count?: Prisma.NodeClosureCountOrderByAggregateInput
  _avg?: Prisma.NodeClosureAvgOrderByAggregateInput
  _max?: Prisma.NodeClosureMaxOrderByAggregateInput
  _min?: Prisma.NodeClosureMinOrderByAggregateInput
  _sum?: Prisma.NodeClosureSumOrderByAggregateInput
}

export type NodeClosureScalarWhereWithAggregatesInput = {
  AND?: Prisma.NodeClosureScalarWhereWithAggregatesInput | Prisma.NodeClosureScalarWhereWithAggregatesInput[]
  OR?: Prisma.NodeClosureScalarWhereWithAggregatesInput[]
  NOT?: Prisma.NodeClosureScalarWhereWithAggregatesInput | Prisma.NodeClosureScalarWhereWithAggregatesInput[]
  ancestorId?: Prisma.StringWithAggregatesFilter<"NodeClosure"> | string
  descendantId?: Prisma.StringWithAggregatesFilter<"NodeClosure"> | string
  depth?: Prisma.IntWithAggregatesFilter<"NodeClosure"> | number
}

export type NodeClosureCreateInput = {
  depth: number
  ancestor: Prisma.NodeCreateNestedOneWithoutClosureAsAncestorInput
  descendant: Prisma.NodeCreateNestedOneWithoutClosureAsDescendantInput
}

export type NodeClosureUncheckedCreateInput = {
  ancestorId: string
  descendantId: string
  depth: number
}

export type NodeClosureUpdateInput = {
  depth?: Prisma.IntFieldUpdateOperationsInput | number
  ancestor?: Prisma.NodeUpdateOneRequiredWithoutClosureAsAncestorNestedInput
  descendant?: Prisma.NodeUpdateOneRequiredWithoutClosureAsDescendantNestedInput
}

export type NodeClosureUncheckedUpdateInput = {
  ancestorId?: Prisma.StringFieldUpdateOperationsInput | string
  descendantId?: Prisma.StringFieldUpdateOperationsInput | string
  depth?: Prisma.IntFieldUpdateOperationsInput | number
}

export type NodeClosureCreateManyInput = {
  ancestorId: string
  descendantId: string
  depth: number
}

export type NodeClosureUpdateManyMutationInput = {
  depth?: Prisma.IntFieldUpdateOperationsInput | number
}

export type NodeClosureUncheckedUpdateManyInput = {
  ancestorId?: Prisma.StringFieldUpdateOperationsInput | string
  descendantId?: Prisma.StringFieldUpdateOperationsInput | string
  depth?: Prisma.IntFieldUpdateOperationsInput | number
}

export type NodeClosureListRelationFilter = {
  every?: Prisma.NodeClosureWhereInput
  some?: Prisma.NodeClosureWhereInput
  none?: Prisma.NodeClosureWhereInput
}

export type NodeClosureOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type NodeClosureAncestorIdDescendantIdCompoundUniqueInput = {
  ancestorId: string
  descendantId: string
}

export type NodeClosureCountOrderByAggregateInput = {
  ancestorId?: Prisma.SortOrder
  descendantId?: Prisma.SortOrder
  depth?: Prisma.SortOrder
}

export type NodeClosureAvgOrderByAggregateInput = {
  depth?: Prisma.SortOrder
}

export type NodeClosureMaxOrderByAggregateInput = {
  ancestorId?: Prisma.SortOrder
  descendantId?: Prisma.SortOrder
  depth?: Prisma.SortOrder
}

export type NodeClosureMinOrderByAggregateInput = {
  ancestorId?: Prisma.SortOrder
  descendantId?: Prisma.SortOrder
  depth?: Prisma.SortOrder
}

export type NodeClosureSumOrderByAggregateInput = {
  depth?: Prisma.SortOrder
}

export type NodeClosureCreateNestedManyWithoutAncestorInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutAncestorInput, Prisma.NodeClosureUncheckedCreateWithoutAncestorInput> | Prisma.NodeClosureCreateWithoutAncestorInput[] | Prisma.NodeClosureUncheckedCreateWithoutAncestorInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutAncestorInput | Prisma.NodeClosureCreateOrConnectWithoutAncestorInput[]
  createMany?: Prisma.NodeClosureCreateManyAncestorInputEnvelope
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
}

export type NodeClosureCreateNestedManyWithoutDescendantInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutDescendantInput, Prisma.NodeClosureUncheckedCreateWithoutDescendantInput> | Prisma.NodeClosureCreateWithoutDescendantInput[] | Prisma.NodeClosureUncheckedCreateWithoutDescendantInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutDescendantInput | Prisma.NodeClosureCreateOrConnectWithoutDescendantInput[]
  createMany?: Prisma.NodeClosureCreateManyDescendantInputEnvelope
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
}

export type NodeClosureUncheckedCreateNestedManyWithoutAncestorInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutAncestorInput, Prisma.NodeClosureUncheckedCreateWithoutAncestorInput> | Prisma.NodeClosureCreateWithoutAncestorInput[] | Prisma.NodeClosureUncheckedCreateWithoutAncestorInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutAncestorInput | Prisma.NodeClosureCreateOrConnectWithoutAncestorInput[]
  createMany?: Prisma.NodeClosureCreateManyAncestorInputEnvelope
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
}

export type NodeClosureUncheckedCreateNestedManyWithoutDescendantInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutDescendantInput, Prisma.NodeClosureUncheckedCreateWithoutDescendantInput> | Prisma.NodeClosureCreateWithoutDescendantInput[] | Prisma.NodeClosureUncheckedCreateWithoutDescendantInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutDescendantInput | Prisma.NodeClosureCreateOrConnectWithoutDescendantInput[]
  createMany?: Prisma.NodeClosureCreateManyDescendantInputEnvelope
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
}

export type NodeClosureUpdateManyWithoutAncestorNestedInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutAncestorInput, Prisma.NodeClosureUncheckedCreateWithoutAncestorInput> | Prisma.NodeClosureCreateWithoutAncestorInput[] | Prisma.NodeClosureUncheckedCreateWithoutAncestorInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutAncestorInput | Prisma.NodeClosureCreateOrConnectWithoutAncestorInput[]
  upsert?: Prisma.NodeClosureUpsertWithWhereUniqueWithoutAncestorInput | Prisma.NodeClosureUpsertWithWhereUniqueWithoutAncestorInput[]
  createMany?: Prisma.NodeClosureCreateManyAncestorInputEnvelope
  set?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  disconnect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  delete?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  update?: Prisma.NodeClosureUpdateWithWhereUniqueWithoutAncestorInput | Prisma.NodeClosureUpdateWithWhereUniqueWithoutAncestorInput[]
  updateMany?: Prisma.NodeClosureUpdateManyWithWhereWithoutAncestorInput | Prisma.NodeClosureUpdateManyWithWhereWithoutAncestorInput[]
  deleteMany?: Prisma.NodeClosureScalarWhereInput | Prisma.NodeClosureScalarWhereInput[]
}

export type NodeClosureUpdateManyWithoutDescendantNestedInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutDescendantInput, Prisma.NodeClosureUncheckedCreateWithoutDescendantInput> | Prisma.NodeClosureCreateWithoutDescendantInput[] | Prisma.NodeClosureUncheckedCreateWithoutDescendantInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutDescendantInput | Prisma.NodeClosureCreateOrConnectWithoutDescendantInput[]
  upsert?: Prisma.NodeClosureUpsertWithWhereUniqueWithoutDescendantInput | Prisma.NodeClosureUpsertWithWhereUniqueWithoutDescendantInput[]
  createMany?: Prisma.NodeClosureCreateManyDescendantInputEnvelope
  set?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  disconnect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  delete?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  update?: Prisma.NodeClosureUpdateWithWhereUniqueWithoutDescendantInput | Prisma.NodeClosureUpdateWithWhereUniqueWithoutDescendantInput[]
  updateMany?: Prisma.NodeClosureUpdateManyWithWhereWithoutDescendantInput | Prisma.NodeClosureUpdateManyWithWhereWithoutDescendantInput[]
  deleteMany?: Prisma.NodeClosureScalarWhereInput | Prisma.NodeClosureScalarWhereInput[]
}

export type NodeClosureUncheckedUpdateManyWithoutAncestorNestedInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutAncestorInput, Prisma.NodeClosureUncheckedCreateWithoutAncestorInput> | Prisma.NodeClosureCreateWithoutAncestorInput[] | Prisma.NodeClosureUncheckedCreateWithoutAncestorInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutAncestorInput | Prisma.NodeClosureCreateOrConnectWithoutAncestorInput[]
  upsert?: Prisma.NodeClosureUpsertWithWhereUniqueWithoutAncestorInput | Prisma.NodeClosureUpsertWithWhereUniqueWithoutAncestorInput[]
  createMany?: Prisma.NodeClosureCreateManyAncestorInputEnvelope
  set?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  disconnect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  delete?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  update?: Prisma.NodeClosureUpdateWithWhereUniqueWithoutAncestorInput | Prisma.NodeClosureUpdateWithWhereUniqueWithoutAncestorInput[]
  updateMany?: Prisma.NodeClosureUpdateManyWithWhereWithoutAncestorInput | Prisma.NodeClosureUpdateManyWithWhereWithoutAncestorInput[]
  deleteMany?: Prisma.NodeClosureScalarWhereInput | Prisma.NodeClosureScalarWhereInput[]
}

export type NodeClosureUncheckedUpdateManyWithoutDescendantNestedInput = {
  create?: Prisma.XOR<Prisma.NodeClosureCreateWithoutDescendantInput, Prisma.NodeClosureUncheckedCreateWithoutDescendantInput> | Prisma.NodeClosureCreateWithoutDescendantInput[] | Prisma.NodeClosureUncheckedCreateWithoutDescendantInput[]
  connectOrCreate?: Prisma.NodeClosureCreateOrConnectWithoutDescendantInput | Prisma.NodeClosureCreateOrConnectWithoutDescendantInput[]
  upsert?: Prisma.NodeClosureUpsertWithWhereUniqueWithoutDescendantInput | Prisma.NodeClosureUpsertWithWhereUniqueWithoutDescendantInput[]
  createMany?: Prisma.NodeClosureCreateManyDescendantInputEnvelope
  set?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  disconnect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  delete?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  connect?: Prisma.NodeClosureWhereUniqueInput | Prisma.NodeClosureWhereUniqueInput[]
  update?: Prisma.NodeClosureUpdateWithWhereUniqueWithoutDescendantInput | Prisma.NodeClosureUpdateWithWhereUniqueWithoutDescendantInput[]
  updateMany?: Prisma.NodeClosureUpdateManyWithWhereWithoutDescendantInput | Prisma.NodeClosureUpdateManyWithWhereWithoutDescendantInput[]
  deleteMany?: Prisma.NodeClosureScalarWhereInput | Prisma.NodeClosureScalarWhereInput[]
}

export type NodeClosureCreateWithoutAncestorInput = {
  depth: number
  descendant: Prisma.NodeCreateNestedOneWithoutClosureAsDescendantInput
}

export type NodeClosureUncheckedCreateWithoutAncestorInput = {
  descendantId: string
  depth: number
}

export type NodeClosureCreateOrConnectWithoutAncestorInput = {
  where: Prisma.NodeClosureWhereUniqueInput
  create: Prisma.XOR<Prisma.NodeClosureCreateWithoutAncestorInput, Prisma.NodeClosureUncheckedCreateWithoutAncestorInput>
}

export type NodeClosureCreateManyAncestorInputEnvelope = {
  data: Prisma.NodeClosureCreateManyAncestorInput | Prisma.NodeClosureCreateManyAncestorInput[]
  skipDuplicates?: boolean
}

export type NodeClosureCreateWithoutDescendantInput = {
  depth: number
  ancestor: Prisma.NodeCreateNestedOneWithoutClosureAsAncestorInput
}

export type NodeClosureUncheckedCreateWithoutDescendantInput = {
  ancestorId: string
  depth: number
}

export type NodeClosureCreateOrConnectWithoutDescendantInput = {
  where: Prisma.NodeClosureWhereUniqueInput
  create: Prisma.XOR<Prisma.NodeClosureCreateWithoutDescendantInput, Prisma.NodeClosureUncheckedCreateWithoutDescendantInput>
}

export type NodeClosureCreateManyDescendantInputEnvelope = {
  data: Prisma.NodeClosureCreateManyDescendantInput | Prisma.NodeClosureCreateManyDescendantInput[]
  skipDuplicates?: boolean
}

export type NodeClosureUpsertWithWhereUniqueWithoutAncestorInput = {
  where: Prisma.NodeClosureWhereUniqueInput
  update: Prisma.XOR<Prisma.NodeClosureUpdateWithoutAncestorInput, Prisma.NodeClosureUncheckedUpdateWithoutAncestorInput>
  create: Prisma.XOR<Prisma.NodeClosureCreateWithoutAncestorInput, Prisma.NodeClosureUncheckedCreateWithoutAncestorInput>
}

export type NodeClosureUpdateWithWhereUniqueWithoutAncestorInput = {
  where: Prisma.NodeClosureWhereUniqueInput
  data: Prisma.XOR<Prisma.NodeClosureUpdateWithoutAncestorInput, Prisma.NodeClosureUncheckedUpdateWithoutAncestorInput>
}

export type NodeClosureUpdateManyWithWhereWithoutAncestorInput = {
  where: Prisma.NodeClosureScalarWhereInput
  data: Prisma.XOR<Prisma.NodeClosureUpdateManyMutationInput, Prisma.NodeClosureUncheckedUpdateManyWithoutAncestorInput>
}

export type NodeClosureScalarWhereInput = {
  AND?: Prisma.NodeClosureScalarWhereInput | Prisma.NodeClosureScalarWhereInput[]
  OR?: Prisma.NodeClosureScalarWhereInput[]
  NOT?: Prisma.NodeClosureScalarWhereInput | Prisma.NodeClosureScalarWhereInput[]
  ancestorId?: Prisma.StringFilter<"NodeClosure"> | string
  descendantId?: Prisma.StringFilter<"NodeClosure"> | string
  depth?: Prisma.IntFilter<"NodeClosure"> | number
}

export type NodeClosureUpsertWithWhereUniqueWithoutDescendantInput = {
  where: Prisma.NodeClosureWhereUniqueInput
  update: Prisma.XOR<Prisma.NodeClosureUpdateWithoutDescendantInput, Prisma.NodeClosureUncheckedUpdateWithoutDescendantInput>
  create: Prisma.XOR<Prisma.NodeClosureCreateWithoutDescendantInput, Prisma.NodeClosureUncheckedCreateWithoutDescendantInput>
}

export type NodeClosureUpdateWithWhereUniqueWithoutDescendantInput = {
  where: Prisma.NodeClosureWhereUniqueInput
  data: Prisma.XOR<Prisma.NodeClosureUpdateWithoutDescendantInput, Prisma.NodeClosureUncheckedUpdateWithoutDescendantInput>
}

export type NodeClosureUpdateManyWithWhereWithoutDescendantInput = {
  where: Prisma.NodeClosureScalarWhereInput
  data: Prisma.XOR<Prisma.NodeClosureUpdateManyMutationInput, Prisma.NodeClosureUncheckedUpdateManyWithoutDescendantInput>
}

export type NodeClosureCreateManyAncestorInput = {
  descendantId: string
  depth: number
}

export type NodeClosureCreateManyDescendantInput = {
  ancestorId: string
  depth: number
}

export type NodeClosureUpdateWithoutAncestorInput = {
  depth?: Prisma.IntFieldUpdateOperationsInput | number
  descendant?: Prisma.NodeUpdateOneRequiredWithoutClosureAsDescendantNestedInput
}

export type NodeClosureUncheckedUpdateWithoutAncestorInput = {
  descendantId?: Prisma.StringFieldUpdateOperationsInput | string
  depth?: Prisma.IntFieldUpdateOperationsInput | number
}

export type NodeClosureUncheckedUpdateManyWithoutAncestorInput = {
  descendantId?: Prisma.StringFieldUpdateOperationsInput | string
  depth?: Prisma.IntFieldUpdateOperationsInput | number
}

export type NodeClosureUpdateWithoutDescendantInput = {
  depth?: Prisma.IntFieldUpdateOperationsInput | number
  ancestor?: Prisma.NodeUpdateOneRequiredWithoutClosureAsAncestorNestedInput
}

export type NodeClosureUncheckedUpdateWithoutDescendantInput = {
  ancestorId?: Prisma.StringFieldUpdateOperationsInput | string
  depth?: Prisma.IntFieldUpdateOperationsInput | number
}

export type NodeClosureUncheckedUpdateManyWithoutDescendantInput = {
  ancestorId?: Prisma.StringFieldUpdateOperationsInput | string
  depth?: Prisma.IntFieldUpdateOperationsInput | number
}



export type NodeClosureSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  ancestorId?: boolean
  descendantId?: boolean
  depth?: boolean
  ancestor?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
  descendant?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["nodeClosure"]>

export type NodeClosureSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  ancestorId?: boolean
  descendantId?: boolean
  depth?: boolean
  ancestor?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
  descendant?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["nodeClosure"]>

export type NodeClosureSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  ancestorId?: boolean
  descendantId?: boolean
  depth?: boolean
  ancestor?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
  descendant?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["nodeClosure"]>

export type NodeClosureSelectScalar = {
  ancestorId?: boolean
  descendantId?: boolean
  depth?: boolean
}

export type NodeClosureOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"ancestorId" | "descendantId" | "depth", ExtArgs["result"]["nodeClosure"]>
export type NodeClosureInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  ancestor?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
  descendant?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
}
export type NodeClosureIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  ancestor?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
  descendant?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
}
export type NodeClosureIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  ancestor?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
  descendant?: boolean | Prisma.NodeDefaultArgs<ExtArgs>
}

export type $NodeClosurePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "NodeClosure"
  objects: {
    ancestor: Prisma.$NodePayload<ExtArgs>
    descendant: Prisma.$NodePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    ancestorId: string
    descendantId: string
    depth: number
  }, ExtArgs["result"]["nodeClosure"]>
  composites: {}
}

export type NodeClosureGetPayload<S extends boolean | null | undefined | NodeClosureDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload, S>

export type NodeClosureCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<NodeClosureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NodeClosureCountAggregateInputType | true
  }

export interface NodeClosureDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeClosure'], meta: { name: 'NodeClosure' } }
  /**
   * Find zero or one NodeClosure that matches the filter.
   * @param {NodeClosureFindUniqueArgs} args - Arguments to find a NodeClosure
   * @example
   * // Get one NodeClosure
   * const nodeClosure = await prisma.nodeClosure.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends NodeClosureFindUniqueArgs>(args: Prisma.SelectSubset<T, NodeClosureFindUniqueArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one NodeClosure that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {NodeClosureFindUniqueOrThrowArgs} args - Arguments to find a NodeClosure
   * @example
   * // Get one NodeClosure
   * const nodeClosure = await prisma.nodeClosure.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends NodeClosureFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, NodeClosureFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first NodeClosure that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NodeClosureFindFirstArgs} args - Arguments to find a NodeClosure
   * @example
   * // Get one NodeClosure
   * const nodeClosure = await prisma.nodeClosure.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends NodeClosureFindFirstArgs>(args?: Prisma.SelectSubset<T, NodeClosureFindFirstArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first NodeClosure that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NodeClosureFindFirstOrThrowArgs} args - Arguments to find a NodeClosure
   * @example
   * // Get one NodeClosure
   * const nodeClosure = await prisma.nodeClosure.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends NodeClosureFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, NodeClosureFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more NodeClosures that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NodeClosureFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all NodeClosures
   * const nodeClosures = await prisma.nodeClosure.findMany()
   * 
   * // Get first 10 NodeClosures
   * const nodeClosures = await prisma.nodeClosure.findMany({ take: 10 })
   * 
   * // Only select the `ancestorId`
   * const nodeClosureWithAncestorIdOnly = await prisma.nodeClosure.findMany({ select: { ancestorId: true } })
   * 
   */
  findMany<T extends NodeClosureFindManyArgs>(args?: Prisma.SelectSubset<T, NodeClosureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a NodeClosure.
   * @param {NodeClosureCreateArgs} args - Arguments to create a NodeClosure.
   * @example
   * // Create one NodeClosure
   * const NodeClosure = await prisma.nodeClosure.create({
   *   data: {
   *     // ... data to create a NodeClosure
   *   }
   * })
   * 
   */
  create<T extends NodeClosureCreateArgs>(args: Prisma.SelectSubset<T, NodeClosureCreateArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many NodeClosures.
   * @param {NodeClosureCreateManyArgs} args - Arguments to create many NodeClosures.
   * @example
   * // Create many NodeClosures
   * const nodeClosure = await prisma.nodeClosure.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends NodeClosureCreateManyArgs>(args?: Prisma.SelectSubset<T, NodeClosureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many NodeClosures and returns the data saved in the database.
   * @param {NodeClosureCreateManyAndReturnArgs} args - Arguments to create many NodeClosures.
   * @example
   * // Create many NodeClosures
   * const nodeClosure = await prisma.nodeClosure.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many NodeClosures and only return the `ancestorId`
   * const nodeClosureWithAncestorIdOnly = await prisma.nodeClosure.createManyAndReturn({
   *   select: { ancestorId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends NodeClosureCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, NodeClosureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a NodeClosure.
   * @param {NodeClosureDeleteArgs} args - Arguments to delete one NodeClosure.
   * @example
   * // Delete one NodeClosure
   * const NodeClosure = await prisma.nodeClosure.delete({
   *   where: {
   *     // ... filter to delete one NodeClosure
   *   }
   * })
   * 
   */
  delete<T extends NodeClosureDeleteArgs>(args: Prisma.SelectSubset<T, NodeClosureDeleteArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one NodeClosure.
   * @param {NodeClosureUpdateArgs} args - Arguments to update one NodeClosure.
   * @example
   * // Update one NodeClosure
   * const nodeClosure = await prisma.nodeClosure.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends NodeClosureUpdateArgs>(args: Prisma.SelectSubset<T, NodeClosureUpdateArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more NodeClosures.
   * @param {NodeClosureDeleteManyArgs} args - Arguments to filter NodeClosures to delete.
   * @example
   * // Delete a few NodeClosures
   * const { count } = await prisma.nodeClosure.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends NodeClosureDeleteManyArgs>(args?: Prisma.SelectSubset<T, NodeClosureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more NodeClosures.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NodeClosureUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many NodeClosures
   * const nodeClosure = await prisma.nodeClosure.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends NodeClosureUpdateManyArgs>(args: Prisma.SelectSubset<T, NodeClosureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more NodeClosures and returns the data updated in the database.
   * @param {NodeClosureUpdateManyAndReturnArgs} args - Arguments to update many NodeClosures.
   * @example
   * // Update many NodeClosures
   * const nodeClosure = await prisma.nodeClosure.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more NodeClosures and only return the `ancestorId`
   * const nodeClosureWithAncestorIdOnly = await prisma.nodeClosure.updateManyAndReturn({
   *   select: { ancestorId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends NodeClosureUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, NodeClosureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one NodeClosure.
   * @param {NodeClosureUpsertArgs} args - Arguments to update or create a NodeClosure.
   * @example
   * // Update or create a NodeClosure
   * const nodeClosure = await prisma.nodeClosure.upsert({
   *   create: {
   *     // ... data to create a NodeClosure
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the NodeClosure we want to update
   *   }
   * })
   */
  upsert<T extends NodeClosureUpsertArgs>(args: Prisma.SelectSubset<T, NodeClosureUpsertArgs<ExtArgs>>): Prisma.Prisma__NodeClosureClient<runtime.Types.Result.GetResult<Prisma.$NodeClosurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of NodeClosures.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NodeClosureCountArgs} args - Arguments to filter NodeClosures to count.
   * @example
   * // Count the number of NodeClosures
   * const count = await prisma.nodeClosure.count({
   *   where: {
   *     // ... the filter for the NodeClosures we want to count
   *   }
   * })
  **/
  count<T extends NodeClosureCountArgs>(
    args?: Prisma.Subset<T, NodeClosureCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], NodeClosureCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a NodeClosure.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NodeClosureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends NodeClosureAggregateArgs>(args: Prisma.Subset<T, NodeClosureAggregateArgs>): Prisma.PrismaPromise<GetNodeClosureAggregateType<T>>

  /**
   * Group by NodeClosure.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NodeClosureGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends NodeClosureGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: NodeClosureGroupByArgs['orderBy'] }
      : { orderBy?: NodeClosureGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, NodeClosureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeClosureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the NodeClosure model
 */
readonly fields: NodeClosureFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for NodeClosure.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__NodeClosureClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  ancestor<T extends Prisma.NodeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.NodeDefaultArgs<ExtArgs>>): Prisma.Prisma__NodeClient<runtime.Types.Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  descendant<T extends Prisma.NodeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.NodeDefaultArgs<ExtArgs>>): Prisma.Prisma__NodeClient<runtime.Types.Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the NodeClosure model
 */
export interface NodeClosureFieldRefs {
  readonly ancestorId: Prisma.FieldRef<"NodeClosure", 'String'>
  readonly descendantId: Prisma.FieldRef<"NodeClosure", 'String'>
  readonly depth: Prisma.FieldRef<"NodeClosure", 'Int'>
}
    

// Custom InputTypes
/**
 * NodeClosure findUnique
 */
export type NodeClosureFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * Filter, which NodeClosure to fetch.
   */
  where: Prisma.NodeClosureWhereUniqueInput
}

/**
 * NodeClosure findUniqueOrThrow
 */
export type NodeClosureFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * Filter, which NodeClosure to fetch.
   */
  where: Prisma.NodeClosureWhereUniqueInput
}

/**
 * NodeClosure findFirst
 */
export type NodeClosureFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * Filter, which NodeClosure to fetch.
   */
  where?: Prisma.NodeClosureWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of NodeClosures to fetch.
   */
  orderBy?: Prisma.NodeClosureOrderByWithRelationInput | Prisma.NodeClosureOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for NodeClosures.
   */
  cursor?: Prisma.NodeClosureWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` NodeClosures from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` NodeClosures.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of NodeClosures.
   */
  distinct?: Prisma.NodeClosureScalarFieldEnum | Prisma.NodeClosureScalarFieldEnum[]
}

/**
 * NodeClosure findFirstOrThrow
 */
export type NodeClosureFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * Filter, which NodeClosure to fetch.
   */
  where?: Prisma.NodeClosureWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of NodeClosures to fetch.
   */
  orderBy?: Prisma.NodeClosureOrderByWithRelationInput | Prisma.NodeClosureOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for NodeClosures.
   */
  cursor?: Prisma.NodeClosureWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` NodeClosures from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` NodeClosures.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of NodeClosures.
   */
  distinct?: Prisma.NodeClosureScalarFieldEnum | Prisma.NodeClosureScalarFieldEnum[]
}

/**
 * NodeClosure findMany
 */
export type NodeClosureFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * Filter, which NodeClosures to fetch.
   */
  where?: Prisma.NodeClosureWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of NodeClosures to fetch.
   */
  orderBy?: Prisma.NodeClosureOrderByWithRelationInput | Prisma.NodeClosureOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing NodeClosures.
   */
  cursor?: Prisma.NodeClosureWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` NodeClosures from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` NodeClosures.
   */
  skip?: number
  distinct?: Prisma.NodeClosureScalarFieldEnum | Prisma.NodeClosureScalarFieldEnum[]
}

/**
 * NodeClosure create
 */
export type NodeClosureCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * The data needed to create a NodeClosure.
   */
  data: Prisma.XOR<Prisma.NodeClosureCreateInput, Prisma.NodeClosureUncheckedCreateInput>
}

/**
 * NodeClosure createMany
 */
export type NodeClosureCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many NodeClosures.
   */
  data: Prisma.NodeClosureCreateManyInput | Prisma.NodeClosureCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * NodeClosure createManyAndReturn
 */
export type NodeClosureCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * The data used to create many NodeClosures.
   */
  data: Prisma.NodeClosureCreateManyInput | Prisma.NodeClosureCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * NodeClosure update
 */
export type NodeClosureUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * The data needed to update a NodeClosure.
   */
  data: Prisma.XOR<Prisma.NodeClosureUpdateInput, Prisma.NodeClosureUncheckedUpdateInput>
  /**
   * Choose, which NodeClosure to update.
   */
  where: Prisma.NodeClosureWhereUniqueInput
}

/**
 * NodeClosure updateMany
 */
export type NodeClosureUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update NodeClosures.
   */
  data: Prisma.XOR<Prisma.NodeClosureUpdateManyMutationInput, Prisma.NodeClosureUncheckedUpdateManyInput>
  /**
   * Filter which NodeClosures to update
   */
  where?: Prisma.NodeClosureWhereInput
  /**
   * Limit how many NodeClosures to update.
   */
  limit?: number
}

/**
 * NodeClosure updateManyAndReturn
 */
export type NodeClosureUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * The data used to update NodeClosures.
   */
  data: Prisma.XOR<Prisma.NodeClosureUpdateManyMutationInput, Prisma.NodeClosureUncheckedUpdateManyInput>
  /**
   * Filter which NodeClosures to update
   */
  where?: Prisma.NodeClosureWhereInput
  /**
   * Limit how many NodeClosures to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * NodeClosure upsert
 */
export type NodeClosureUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * The filter to search for the NodeClosure to update in case it exists.
   */
  where: Prisma.NodeClosureWhereUniqueInput
  /**
   * In case the NodeClosure found by the `where` argument doesn't exist, create a new NodeClosure with this data.
   */
  create: Prisma.XOR<Prisma.NodeClosureCreateInput, Prisma.NodeClosureUncheckedCreateInput>
  /**
   * In case the NodeClosure was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.NodeClosureUpdateInput, Prisma.NodeClosureUncheckedUpdateInput>
}

/**
 * NodeClosure delete
 */
export type NodeClosureDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
  /**
   * Filter which NodeClosure to delete.
   */
  where: Prisma.NodeClosureWhereUniqueInput
}

/**
 * NodeClosure deleteMany
 */
export type NodeClosureDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which NodeClosures to delete
   */
  where?: Prisma.NodeClosureWhereInput
  /**
   * Limit how many NodeClosures to delete.
   */
  limit?: number
}

/**
 * NodeClosure without action
 */
export type NodeClosureDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the NodeClosure
   */
  select?: Prisma.NodeClosureSelect<ExtArgs> | null
  /**
   * Omit specific fields from the NodeClosure
   */
  omit?: Prisma.NodeClosureOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NodeClosureInclude<ExtArgs> | null
}
